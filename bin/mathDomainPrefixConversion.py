import wolframalpha
import wolframAppID
import pandas as pd
import binutil
import dreamcoder.domains.mathDomain.mathDomainPrimitives as mdp

class infix_to_prefix:
    '''
    Converts ConPoLe Equations in infix notation to a prefix notation for parsing by DreamSolver's system.
    '''
    precedence={'^':5,'*':4,'/':4,'+':3,'-':3,'(':2,')':1, ' ^':5,' *':4, ' /':4,' +':3,' -':3,' (':2,' )':1}
    
    def __init__(self):
        self.items=[]
        self.size=-1
    
    def push(self,value):
        self.items.append(value)
        self.size+=1
    
    def pop(self):
        if self.isempty():
            return 0
        else:
            self.size-=1
            return self.items.pop()
    
    def isempty(self):
        if(self.size==-1):
            return True
        else:
            return False
    
    def seek(self):
        if self.isempty():
            return False
        else:
            return self.items[self.size]
    
    def is0perand(self,i):
        if i.isalpha() or i in '1234567890':
            return True
        else:
            return False
    
    def reverse(self,expr):
        rev=""
        for i in expr:
            if i == '(':
                i=')'
            elif i == ')':
                i='('
            rev=i+rev
        return rev
    
    def infixtoprefix (self,expr):
        prefix=""
        for ind in range(len(expr)):
            i = expr[ind]
            if self.is0perand(i):
                if ind<len(expr)-1 and expr[ind+1]=='-':
                    prefix += ' )'+i+'-('
                else:
                    prefix += ' )'+i+'('
            elif(i in '+*/^'):
                while(len(self.items)and self.precedence[i] < self.precedence[self.seek()]):
                    prefix+=self.pop()
                self.push(" "+i)
            elif(i == '-'):
                if ind>0 and expr[ind-1]==' ' and ind<len(expr)-1 and expr[ind+1]==' ':
                    while(len(self.items)and self.precedence[i] < self.precedence[self.seek()]):
                        prefix+=self.pop()
                    self.push(" "+i)
            elif i == ')':
                self.push(i)
            elif i == '(':
                o = self.pop()
                while o!=')' and o!=0:
                    prefix += o
                    o = self.pop()
            #end of for
        while len(self.items):
            if(self.seek()=='('):
                self.pop()
            else:
                prefix+=self.pop()
                #print(prefix)
        return prefix

def numberOfArgs(s):

    """
    Computes the number of times the brackets are perfectly matched (i.e. number of `(` = number of `)` ) to count the number of arguments in that string.

    Inputs: 
    - s is an equation string in prefix notation
    Returns:
    - an integer numMatched, which is equivalent to the number of arguments

    """
    numOpenBrPair = 0
    numMatched = 0
    for i in s:
        if i=="(":
            numOpenBrPair+=1
        elif i==")":
            numOpenBrPair-=1
            if numOpenBrPair==0:
                numMatched+=1
    return numMatched

def bracketize(s):
    
    '''
    Ensure that the brackets of the generated prefix notation match the format expected by the treefy() function.
    
    Inputs:
    - s is a prefix string generated by the infix_to_prefix objects
    Returns:
    - a string whose brackets are matched in a format expected by mdp.treefy()

    '''
    if len(s) <= 0 or s[0] not in "+-*/^":
        return s
    elif s[0] == "-" and s[1] != " ":
        #print(s)
        return s
    else:
        nextOpInd = max(s.rfind("+ "), s.rfind("- "), s.rfind("* "), s.rfind("/ "), s.rfind("^ ")) 
        ind2 = None
        if nextOpInd==0:
            return "(" + s[0] + " " + s[2:] + ")"
        elif nextOpInd==2 or numberOfArgs(s[nextOpInd:])!=2:
            ind2 = s.rfind("(") 
        else:
            ind2 = nextOpInd
        ind1 = 2
        s1 = s[ind1:ind2]
        s2 = s[ind2:len(s)]
        #print("The split is: ")
        #print(s)
        #print(s1)
        #print(s2)
        return "(" + s[0] + " " + bracketize(s1) + " " + bracketize(s2) + ")"

def infix_to_prefix_conversion(equation):
    """
    Accepts infix equation string as input, generates a prefix string as output.

    Inputs:
    - equation, a string containing an equation in infix notation
    Returns:
    - a string containing an equation in prefix notation, or None if no equivalent string exists.
    """
    subtree = equation.split('=')
    subtree_rev = [sub[::-1] for sub in subtree]

    obj1 = infix_to_prefix()
    result1 = obj1.infixtoprefix(subtree_rev[0])
    obj2 = infix_to_prefix() 
    result2 = obj2.infixtoprefix(subtree_rev[1])

    if (result1!=False and result2!=False):
        result = '(= ' + bracketize(result1[::-1]) + ' ' + bracketize(result2[::-1]) + ')'  
        result = result.replace("( (", "((")
        result = result.replace(") )", "))") 
        result = result.replace("  ", " ")
        return result
    else:
        return None

def txt_infix_to_csv_prefix(inputAddress, outputAddress):

    """
    Applies equation conversion from infix to prefix style on a .txt dataset. Solves the equations using Wolfram prior to saving all equations and solutions in both infix and prefix format.

    Inputs:
    - inputAddress is an address of a .txt file containing infix equations following a similar format as the conpole dataset. For example, an acceptable argument would be 'cognitiveTutorDataset.txt'.
    - outputAddress is an address of a .csv file to where the new prefix and infix equations should be saved. For example, an acceptable argument would be'conpoleDatasetPrefix.csv'.
    """

    EQ_FILE_ADDRESS = inputAddress

    df = pd.DataFrame({'Infix_Eq': [], 'Prefix_Eq': [], 'Working': [], 'Infix_Sol': [], 'Prefix_Sol': []})
    
    with open(EQ_FILE_ADDRESS) as equationsFile:        

        eq_num = 0
        
        for equation in equationsFile:
            
            appID = wolframAppID.appID() #This function returns the Wolfram Alpha App ID
            client = wolframalpha.Client(appID)
            response = client.query("Solve for x: "+equation)
            solution = list(response.results)[-1].text #Last item of generator response

            equation_new = equation
            
            for i in '1234567890':
                equation_new = equation_new.replace(i+'x', i+' * x')

            prefix_eq = infix_to_prefix_conversion(equation_new)

            if prefix_eq!=None and solution!="(no solutions exist)" and mdp.detreefy(mdp.treefy(prefix_eq))==prefix_eq:
                #print("is",result)
                prefix_sol = None
                if solution is not None:
                    prefix_sol = infix_to_prefix_conversion(solution)
                df.loc[len(df.index)] = [equation, prefix_eq, mdp.detreefy(mdp.treefy(prefix_eq))==prefix_eq, solution, prefix_sol]
                eq_num+=1
            print("Equation " + str(eq_num) + "......DONE ")
    df.to_csv(outputAddress)
    #Manually remove all equations with no solutions and fix the equations with Working column set to FALSE

def csv_infix_to_csv_prefix(inputAddress, outputAddress, swap=False):

    """
    Applies equation conversion from infix to prefix style on a .csv dataset. Solves the equations using Wolfram prior to saving all equations and solutions in both infix and prefix format.

    Inputs:
    - inputAddress is an address of a .txt file containing infix equations following a similar format as the conpole dataset. For example, an acceptable argument would be 'cognitiveTutorDataset.txt'.
    - outputAddress is an address of a .csv file to where the new prefix and infix equations should be saved. For example, an acceptable argument would be'conpoleDatasetPrefix.csv'.
    """

    EQ_FILE_ADDRESS = inputAddress

    df = pd.DataFrame({'Infix_Eq': [], 'Prefix_Eq': [], 'Working': [], 'Infix_Sol': [], 'Prefix_Sol': []})
    
    input_df = pd.read_csv(inputAddress)
    print(input_df)
    eq_num = 0
    eq_list = input_df.iloc[:, 0].tolist()
    #print(eq_list)
    new_eq_list = []
    
    for eq in eq_list:
        new_eq_list.append(eq)
        
    #Swap Equations in Dataset (Optional)
    if swap:
        for eq in eq_list:    
            terms = eq.split("=")
            new_eq_list.append(f"{terms[1]}={terms[0]}")

    for equation in new_eq_list:

        appID = wolframAppID.appID() #This function returns the Wolfram Alpha App ID
        client = wolframalpha.Client(appID)
        response = client.query("Solve for x: "+equation)
        solution = None
        try:
            solution = list(response.results)[-1].text #Last item of generator response
        except:
            print(f"Wolfram Generated No Solution for equation: {equation}")
            solution = ''
        
        equation_new = equation
        
        for i in '1234567890':
            equation_new = equation_new.replace(i+'x', i+' * x')

        prefix_eq = infix_to_prefix_conversion(equation_new)
        try:
            if prefix_eq!=None and solution!="(no solutions exist)" and mdp.detreefy(mdp.treefy(prefix_eq))==prefix_eq:
                #print("is",result)
                prefix_sol = None
                if solution is not None:
                    prefix_sol = infix_to_prefix_conversion(solution)
                df.loc[len(df.index)] = [equation, prefix_eq, mdp.detreefy(mdp.treefy(prefix_eq))==prefix_eq, solution, prefix_sol]
        except Exception as e:
                print(equation)
                print(e)
        eq_num+=1
        print("Equation " + str(eq_num) + "......DONE ")
    df.to_csv(outputAddress)
    #Manually remove all equations with no solutions and fix the equations with Working column set to FALSE


if __name__ == "__main__":
    csv_infix_to_csv_prefix("data/mathDomain/trainingEquations.csv", "data/mathDomain/trainingEquationsModified.csv", True) 